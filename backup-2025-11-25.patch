diff --git a/resources/js/Components/CanvasEditor.vue b/resources/js/Components/CanvasEditor.vue
index 114f8e0..3efb4d6 100644
--- a/resources/js/Components/CanvasEditor.vue
+++ b/resources/js/Components/CanvasEditor.vue
@@ -164,6 +164,7 @@
   @add-curved-text="addTextOnPath"     
   @add-rectangle="addRectangle"
   @add-circle="addCircle"
+  @start-line-tool="beginLineDrawMode"
   @upload-image="uploadImage"
   @bring-to-front="bringToFront"
   @send-to-back="sendToBack"
@@ -268,6 +269,12 @@ const formWidthIn = ref(props.initialWidthIn)
 const formHeightIn = ref(props.initialHeightIn)
 const dimError = ref('')
 
+// --- Line tool state ---
+const currentTool = ref<'none' | 'line'>('none')
+let isDrawingLine = false
+let activeLine: fabric.Line | null = null
+let lineStart = { x: 0, y: 0 }
+
 /*const template = signTemplates[props.signType];*/
 const canvasEl = ref(null)
 const fileInput = ref(null)
@@ -283,7 +290,8 @@ const activeObj = ref(null);
 const viewport = reactive({ w: 1200, h: 620 }) // updated on mount/resize
 const pad = 40 // screen-pixel padding around the face when fitting
 const hasSelection = ref(false)
-const selectionKind = ref<'none' | 'text' | 'text-on-path' | 'rect' | 'circle' | 'generic'>('none')
+const selectionKind = ref<'none' | 'text' | 'text-on-path' | 'rect' | 'circle' | 'line' | 'generic'>('none')
+
 const SHADOW_KEYS = ['shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY']
 const styleState = reactive({
   fill: '#000000' as string | null,
@@ -382,14 +390,14 @@ function bindCanvasSelectionEvents(fCanvas) {
   };
   fCanvas.on('selection:created', (e) => {
     /*console.log("e.selected[0] is: "+e.selected[0])
-    console.log("Calling hydrateStyleFromObject, passing  e.selected[0]")
-    hydrateStyleFromObject(e.selected?.[0] ?? null);*/
+    console.log("Calling hydrateStyleFromObject, passing  e.selected[0]")*/
+    hydrateStyleFromObject(e.selected?.[0] ?? null);
     onSelectionChange
     syncActive;
     
   });
   fCanvas.on('selection:updated', (e) => {
-    /*hydrateStyleFromObject(e.selected?.[0] ?? null);*/
+    hydrateStyleFromObject(e.selected?.[0] ?? null);
     onSelectionChange
     syncActive;
     
@@ -397,7 +405,7 @@ function bindCanvasSelectionEvents(fCanvas) {
   fCanvas.on('selection:cleared', () => { 
     onSelectionClear
     activeObj.value = null; 
-   /* hydrateStyleFromObject(null);*/
+    hydrateStyleFromObject(null);
   });
 }
 
@@ -474,6 +482,10 @@ onMounted(async () => {
   canvas.on('selection:created', () => (hasSelection.value = true))
   canvas.on('selection:updated', () => (hasSelection.value = true))
   canvas.on('selection:cleared', () => (hasSelection.value = false))
+  //for line drawing.
+  canvas.on('mouse:down', handleCanvasMouseDown)
+  canvas.on('mouse:move', handleCanvasMouseMove)
+  canvas.on('mouse:up', handleCanvasMouseUp)
 
   canvas.on('object:moving', (e) => {
     if (!snapToGrid.value) return
@@ -792,7 +804,7 @@ function handlePropertiesStyleChange(patch: Record<string, any>) {
   const obj = canvas.getActiveObject()
   if (!obj) return
 
-  const { shadow, ...rest } = patch
+  const { shadow, gradientFill, ...rest } = patch
 
   // Helper: apply fill/stroke/strokeWidth to all text children in a group
   const applyFillStrokeToTextChildren = (node: any) => {
@@ -853,12 +865,37 @@ function handlePropertiesStyleChange(patch: Record<string, any>) {
     }
   }
 
+  // Apply gradient fill if requested
+  if (gradientFill) {
+    // Map direction → coords in percentage space
+    let coords: fabric.Gradient['coords']
+    switch (gradientFill.direction) {
+      case 'vertical':
+        coords = { x1: 0, y1: 0, x2: 0, y2: 1 }
+        break
+      case 'diagonal':
+        coords = { x1: 0, y1: 0, x2: 1, y2: 1 }
+        break
+      case 'horizontal':
+      default:
+        coords = { x1: 0, y1: 0, x2: 1, y2: 0 }
+        break
+    }
+
+    const gradient = new fabric.Gradient({
+      type: 'linear',
+      gradientUnits: 'percentage',
+      coords,
+      colorStops: gradientFill.colorStops
+    })
+
+    obj.set('fill', gradient)
+  }
+
   canvas.renderAll()
   syncStyleStateFromObject(obj)
 }
 
-
-
 function getSelectionTextObjects(): fabric.Object[] {
   if (!canvas) return []
   const objs = canvas.getActiveObjects?.() || []
@@ -1210,6 +1247,19 @@ function addCircle() {
   canvas.requestRenderAll();
 }
 
+function beginLineDrawMode() {
+  if (!canvas) return
+
+  currentTool.value = 'line'
+  isDrawingLine = false
+  activeLine = null
+
+  // Optional: disable current selection while drawing
+  canvas.discardActiveObject()
+  canvas.defaultCursor = 'crosshair'
+  canvas.renderAll()
+}
+
 
 // === [CurvedText] reactive UI state ===
 const curvedUI = reactive({
@@ -1737,6 +1787,7 @@ function getSelectionKind(obj: any) {
 
   if (obj.isType?.('rect')) return 'rect'
   if (obj.isType?.('circle')) return 'circle'
+  if (obj.isType?.('line')) return 'line'
 
   return 'generic'
 }
@@ -1760,6 +1811,63 @@ function onSelectionClear() {
   }
 }
 
+function handleCanvasMouseDown(opt: fabric.IEvent<MouseEvent>) {
+  if (currentTool.value !== 'line') return
+  if (!canvas) return
+
+  const pointer = canvas.getPointer(opt.e)
+
+  lineStart = { x: pointer.x, y: pointer.y }
+
+  activeLine = new fabric.Line(
+    [pointer.x, pointer.y, pointer.x, pointer.y],
+    {
+      stroke: '#000000',
+      strokeWidth: 2,
+      selectable: true,
+      evented: true,
+      // optional:
+      // strokeUniform: true
+    }
+  )
+
+  canvas.add(activeLine)
+  isDrawingLine = true
+}
+
+function handleCanvasMouseMove(opt: fabric.IEvent<MouseEvent>) {
+  if (currentTool.value !== 'line') return
+  if (!isDrawingLine) return
+  if (!canvas || !activeLine) return
+
+  const pointer = canvas.getPointer(opt.e)
+
+  activeLine.set({
+    x2: pointer.x,
+    y2: pointer.y
+  })
+
+  canvas.renderAll()
+}
+
+function handleCanvasMouseUp(_opt: fabric.IEvent<MouseEvent>) {
+  if (currentTool.value !== 'line') return
+  if (!canvas) return
+
+  if (isDrawingLine && activeLine) {
+    activeLine.setCoords()
+  }
+
+  isDrawingLine = false
+  activeLine = null
+
+  // Exit line mode after drawing one line.
+  currentTool.value = 'none'
+  canvas.defaultCursor = 'default'
+  canvas.renderAll()
+}
+
+
 </script>
 
 <style scoped>
diff --git a/resources/js/Components/DesignerToolsPanel.vue b/resources/js/Components/DesignerToolsPanel.vue
index 20ebb18..808c10f 100644
--- a/resources/js/Components/DesignerToolsPanel.vue
+++ b/resources/js/Components/DesignerToolsPanel.vue
@@ -9,6 +9,10 @@
     </button>
     <button class="btn mx-2 my-1" @click="$emit('add-rectangle')">Add Rectangle</button>
     <button class="btn mx-2 my-1" @click="$emit('add-circle')">Add Circle</button>
+    <!-- Click & Drag Line Tool -->
+    <button type="button" class="btn mx-2 my-1" @click="emit('start-line-tool')">
+      Click &amp; Drag Line
+    </button>
     <button class="btn mx-2 my-1" @click="$emit('upload-image')">Upload Image</button>
     <button class="btn mx-2 my-1" @click="$emit('bring-to-front')">Bring to Front</button>
     <button class="btn mx-2 my-1" @click="$emit('send-to-back')">Send to Back</button>
@@ -65,8 +69,7 @@ const props = defineProps<{
 const emit = defineEmits([
   'add-text','add-curved-text','add-rectangle','add-circle','upload-image','bring-to-front','send-to-back',
   'delete-selected','align-left','align-center','align-right','align-top','align-middle',
-  'align-bottom','group','ungroup','toggle-snap','file-upload','toggle-grid','fonts'
-])
+  'align-bottom','group','ungroup','toggle-snap','file-upload','toggle-grid','fonts','start-line-tool'])
 
 </script>
 
diff --git a/resources/js/Components/ObjectPropertiesPanel.vue b/resources/js/Components/ObjectPropertiesPanel.vue
index f66844b..156670c 100644
--- a/resources/js/Components/ObjectPropertiesPanel.vue
+++ b/resources/js/Components/ObjectPropertiesPanel.vue
@@ -78,6 +78,105 @@
           </div>
         </div>
       </div>
+
+<!-- GRADIENT FILL (text + shapes) -->
+<section
+  v-if="gradientSupported"
+  class="mt-4 border-t pt-3"
+>
+  <h4 class="mb-2 text-xs font-semibold">Gradient Fill</h4>
+
+  <label class="flex items-center gap-2 text-xs mb-2">
+    <input
+      type="checkbox"
+      v-model="gradientEnabled"
+      @change="applyGradientFill"
+    />
+    Enable Gradient Fill
+  </label>
+
+  <div v-if="gradientEnabled" class="grid grid-cols-1 gap-2 md:grid-cols-2">
+    <!-- Start Color -->
+    <div>
+      <label class="block mb-1 text-xs font-medium">Start Color</label>
+      <input
+        type="color"
+        class="w-10 h-8 border rounded cursor-pointer"
+        v-model="gradientUI.startColor"
+        @input="applyGradientFill"
+      />
+    </div>
+
+    <!-- End Color -->
+    <div>
+      <label class="block mb-1 text-xs font-medium">End Color</label>
+      <input
+        type="color"
+        class="w-10 h-8 border rounded cursor-pointer"
+        v-model="gradientUI.endColor"
+        @input="applyGradientFill"
+      />
+    </div>
+
+    <!-- Direction -->
+    <div class="md:col-span-2">
+      <label class="block mb-1 text-xs font-medium">Direction</label>
+      <select
+        class="w-full p-1 text-xs border rounded"
+        v-model="gradientUI.direction"
+        @change="applyGradientFill"
+      >
+        <option value="horizontal">Left → Right</option>
+        <option value="vertical">Top → Bottom</option>
+        <option value="diagonal">Top-Left → Bottom-Right</option>
+      </select>
+    </div>
+  </div>
+</section>
+
+
+<!-- LINE-SPECIFIC PROPERTIES -->
+<div
+  v-if="kind === 'line'"
+  class="mt-4 border-t pt-3"
+>
+  <h4 class="mb-2 text-xs font-semibold">Line Properties</h4>
+
+  <!-- Line Color (alias of stroke) -->
+  <div class="flex items-center gap-2 mb-2">
+    <label class="block text-xs font-medium">Line Color</label>
+    <input
+      type="color"
+      class="w-10 h-8 border rounded cursor-pointer"
+      :value="styleState.stroke ?? '#000000'"
+      @input="onStyleChange({ stroke: ($event.target as HTMLInputElement).value })"
+    />
+    <input
+      type="text"
+      class="w-24 p-1 text-xs border rounded"
+      :value="styleState.stroke ?? ''"
+      placeholder="#000000"
+      @change="onStyleChange({ stroke: ($event.target as HTMLInputElement).value })"
+    />
+  </div>
+
+  <!-- Line Thickness (alias of strokeWidth) -->
+  <div class="flex items-center gap-2">
+    <label class="block text-xs font-medium">Line Thickness</label>
+    <input
+      type="number"
+      min="0"
+      step="0.5"
+      class="w-20 p-1 text-xs border rounded"
+      :value="styleState.strokeWidth ?? 1"
+      @change="onStyleChange({
+        strokeWidth: Number(($event.target as HTMLInputElement).value) || 1
+      })"
+    />
+  </div>
+</div>
+
+
       <!-- Shadow Section -->
 <section class="mt-4 border-t pt-3">
   <h4 class="text-xs font-semibold mb-1">Drop Shadow</h4>
@@ -343,10 +442,8 @@ import { fabric } from '@/utils/fabricRef';
 
 type FontOpt = { family: string } | string
 
-
-
 const props = defineProps<{    
-  kind: 'none' | 'text' | 'text-on-path' | 'rect' | 'circle' | 'generic',
+  kind: 'none' | 'text' | 'text-on-path' | 'rect' | 'circle' | 'generic' | 'line',
   hasSelection: boolean,
   styleState: {
     fill?: string | null
@@ -367,6 +464,22 @@ const props = defineProps<{
   pathMeta?: any | null  // meta about the current text-on-path selection
 }>()
 
+const isTextKind = computed(
+  () => props.kind === 'text' || props.kind === 'text-on-path'
+)
+
+const kindLabelMap: Record<string, string> = {
+  none: 'None',
+  text: 'Text',
+  'text-on-path': 'Text on Path',
+  rect: 'Rectangle',
+  circle: 'Circle',
+  line: 'Line', 
+  generic: 'Object',
+}
+
+const kindLabel = computed(() => kindLabelMap[props.kind] ?? 'Object')
+
 // --- Text-on-Path presets (move from DesignerToolsPanel.vue) ---
 /** Path presets */
 const PRESETS = [
@@ -415,7 +528,6 @@ watch(
       shadowEnabled.value = false
       return
     }
-
     shadowEnabled.value = true
     shadow.color = sh.color ?? '#000000'
     shadow.blur = sh.blur ?? 0
@@ -459,6 +571,43 @@ function updateShadow() {
   })
 }
 
+// ------------------------------------------------------
+// GRADIENT FILL UI STATE (text + shapes)
+// ------------------------------------------------------
+const gradientEnabled = ref(false)
+
+const gradientUI = reactive({
+  startColor: '#ff0000',
+  endColor: '#0000ff',
+  direction: 'horizontal' as 'horizontal' | 'vertical' | 'diagonal'
+})
+
+// Which kinds support gradient?
+const gradientSupported = computed(() =>
+  props.hasSelection &&
+  ['text', 'rect', 'circle', 'generic'].includes(props.kind)
+  // add 'text-on-path' here later if desired
+)
+
+// Emit gradientFill descriptor (CanvasEditor will build fabric.Gradient)
+function applyGradientFill() {
+  if (!gradientEnabled.value) {
+    // User can revert to solid fill via normal Fill control.
+    return
+  }
+
+  emit('change-style', {
+    gradientFill: {
+      type: 'linear',
+      direction: gradientUI.direction,
+      colorStops: [
+        { offset: 0, color: gradientUI.startColor },
+        { offset: 1, color: gradientUI.endColor }
+      ]
+    }
+  })
+}
+
 
 const emit = defineEmits<{
   (e: 'change-style', patch: Record<string, any>): void
@@ -470,24 +619,6 @@ function onStyleChange(patch: Record<string, any>) {
   emit('change-style', patch)
 }
 
-
-
-const isTextKind = computed(
-  () => props.kind === 'text' || props.kind === 'text-on-path'
-)
-
-const kindLabelMap: Record<string, string> = {
-  none: 'None',
-  text: 'Text',
-  'text-on-path': 'Text on Path',
-  rect: 'Rectangle',
-  circle: 'Circle',
-  generic: 'Object',
-}
-
-const kindLabel = computed(() => kindLabelMap[props.kind] ?? 'Object')
-
-
 watch(
   () => props.pathMeta,
   (meta) => {
